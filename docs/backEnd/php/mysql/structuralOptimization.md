## 设计步骤

### 需求分析

### 逻辑设计

#### 范式化设计

#### 反范式化设计

1. 不存在多对多，就可以将关系表进行反范式化，避免过度关联。

### 物理设计

#### 数据库，表名，字段

#### 数据库存储引擎（Innodb）

#### 数据类型

数字 > 日期或二进制 >  字符类型

1. 整数
   1. tinyint 2^8 = 0~255
   2. smallint 2^(2*8) = 0~655355
   3. mediumint 2^(3*8) 
   4. int 2^(4*8)
   5. bigint 2^(8*8)
> a:int(2)并不能节省数据库空间。（这里的长度又叫“显示宽度”，仅仅是在特定条件下限定显示效果的（接下来谈），而和存储空间并无关系。我们已经知道int类型的存储需要占用4个字节，不管int(11)还是int(2)，占用空间都是4个字节。所以int(2)并不能节省空间！！！）
> 
> b:并不能限定字段的存储范围。（还有一种常见的误解，就是int(2)的意思是只能存储0-99，实际上也不是的，只要是字段类型允许的范围内，都是可以存储的，int(2)可以存储的范围是正负21亿！！！，而且存进去的都能显示出来。）
> 
> c:既然如此哪还有什么用？这里最大的用处是和填充零进行配合。当字段选择了零填充，并且显示宽度设置为int(2)之后，所有不足显示宽度的数字前面都会被零填充。比如1会显示为01。这才是int(2)的作用。


2. 实数类型
      1. float：4个字节
      2. double：8个字节
      3. decimal：每4个字节存9个数字，小数点占用1个字节 ，如decimal(18,9)占用9个字节；最多存储65个数字；

>财务就用decimal,避免产生误差

3. varchar
    1. 存储变长的字符串，只占用必要的存储空间。
    2. 最大长度比平均长度大很多
    3. 很少被更新
    4. 使用多字节多字符集存储字符串

4. char
   1. 定长
   2. 删除末尾的空格
   3. 最大宽度为255
   4. 经常被更新，长度固定，如md5的密码、性别
   

5. 日期
   1. datatime 和时区无关
      1. datatime = YYYY-MM-DD HH:MM:SS[.fraction]
      2. datatime(6) = YYYY-MM-DD HH:MM:SS.fraction
      3. 占用8个字节
      4. 与时区无关
      5. 1000-01-01 00:00:00 9999-12-31 23:59:59
   2. timestap根据时区自动计算显示时间（虽然显示的时间，但是存储的时候还是用时间戳存储的）
      1. 时间戳
      2. 占用4个字节（最终存储的是int）
      3. 1970-01-01 2038-1-19
      4. 当前列的数据被修改的时候，第一个timestap会自动修改。
6. 时间
   1. data 
      1. 占用3个字节
   2. time
7. 主键
   1. 尽可能小
   2. 顺序增长
   3. innodb的主键和业务主键可以不一样。

### 维护优化




